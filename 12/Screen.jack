// This file is part of nand2tetris, as taught in The Hebrew University, and
// was written by Aviv Yaish. It is an extension to the specifications given
// [here](https://www.nand2tetris.org) (Shimon Schocken and Noam Nisan, 2017),
// as allowed by the Creative Common Attribution-NonCommercial-ShareAlike 3.0
// Unported [License](https://creativecommons.org/licenses/by-nc-sa/3.0/).

/**
 * A library of functions for displaying graphics on the screen.
 * The Hack physical screen consists of 256 rows (indexed 0..255, top to bottom)
 * of 512 pixels each (indexed 0..511, left to right). The top left pixel on 
 * the screen is indexed (0,0).
 */
class Screen {
    // TODO DEBUG
        static Array screen;
        static boolean color;

        /** Initializes the Screen. */
        function void init() {
            let screen = 16384; // base location of screen memory
            do Screen.clearScreen();
            do Screen.setColor(true);
            return;
        }

        /** Erases the entire screen. */
        function void clearScreen() {
            var int i;
            let i = 0;
            while (i < 8192) {
                let screen[i] = 0;
                let i = i+1;
            }
            return;
        }

        /** Sets the current color, to be used for all subsequent drawXXX commands.
         *    Black is represented by true, white by false. */
        function void setColor(boolean b) {
            let color = b;
            return;
        }

        /** returns true if x or y is out of bounds */
        function boolean outOfBounds(int x, int y) {
            return ((x < 0) | (x > 511) | (y < 0) | (y > 255)); // the screen is 512x256 px
        }

        /** Draws the (x,y) pixel, using the current color. */
        function void drawPixel(int x, int y) {
            var int xmod16, address;
            if (Screen.outOfBounds(x, y)) {
                do Sys.error(7); // illegal pizel coords
            }
            let xmod16 = (x & 15);
            let address = (^(^(^(^(^y))))) + (#(#(#(#x)))); // since 16 and 32 are powers of 2 we can use shifts for the division and multiplication
            if (color) {
                // TODO: ask will my OS files be tested together? can I create internal functions
                let screen[address] = (screen[address] | (Math.GetTwoToThe(xmod16))); // or with 0001000...0 guarantees the required bit is on  
            } else {
                let screen[address] = (screen[address] & (~(Math.GetTwoToThe(xmod16))));// and with 1111011...1 guarantees the required bit is off
            }
            return;
        }

        /** Draws a line from pixel (x1,y1) to pixel (x2,y2), using the current color. */
        function void drawLine(int x1, int y1, int x2, int y2) {
            // The case where x1 != x2 and y1 != y2 should be implemented without
            // multiplication or division.
            // Pseudocode:
            // 1. let x = x1, y = y1, a = 0, b = 0, diff = 0
            // 2. Compute dx and dy
            // 3. while ((a <= dx) and (b <= dy))
            // 4.   do drawPixel(x+a, y+b)
            // 5.   if (diff < 0) { let a=a+1, diff=diff+dy }
            // 6.   else          { let b=b+1, diff=diff-dx }
            //
            // The case where y1 == y2 can be implemented efficiently by
            // trying to draw as many pixels as possible in a single assignment,
            // similarly to Fill in project 4.
            var int x, dx, y, dy, a, b, diff, dx, dy;
            if (Screen.outOfBounds(x1, y1) | Screen.outOfBounds(x2, y2)) {
                do Sys.error(8); // illegal line coords
            }
            if ((x1 = x2) & (y1 = y2)) {
                do Screen.drawPixel(x1, y1);
                return;
            }
            if (~((y1 = y2) | (x1 = x2))) { // x1 != x2 and y1 != y2
                let a = 0;
                let b = 0;
                let diff = 0;
                let x = Math.min(x1, x2);
                let dx = Math.max(x1, x2) - x;
                if (((x1 < x2 ) & (y1 < y2)) | ((x1 > x2) & (y1 > y2))) {
                    // northeast direction (/) => southeast on screen (\)
                    let y = Math.min(y1, y2);
                    let dy = Math.max(y1, y2) - y;
                    while (~((a > dx) | (b > dy))) { // a <= dx and b <= dy
                        do Screen.drawPixel(x+a, y+b);
                        if (diff < 0) { // b/a > dy/dx -> diff = a*dy-b*dx < 0
                            let a = a+1;
                            let diff = diff+dy;
                        } else {
                            let b = b+1;
                            let diff = diff-dx;
                        }
                    }
                } else {
                    // southeast direction (\) => northeast on screen (/)
                    let y = Math.max(y1, y2);
                    let dy = Math.min(y1, y2) - y; // dy < 0
                    while(~((a > dx) | (b > -dy))) { // a <= dx and b <= -dy
                        do Screen.drawPixel(x+a, y-b);
                        if (diff < 0) { // -b/a > dy/dx -> diff = a*dy+b*dx < 0
                            let a = a+1;
                            let diff = diff+dy;
                        } else {
                            let b = b+1;
                            let diff = diff+dx;
                        }
                    }
                }
            } else {
                if (x1 = x2) {
                    let y = Math.min(y1, y2);
                    let dy = Math.max(y1, y2) - y;
                    while (b < dy+1) {
                        do Screen.drawPixel(x1, y+b);
                        let b = b+1;
                    }
                } else { // y1 = y2
                    if (x1 > x2) {
                        do Screen.drawHorizonal(x2, x1, y1);
                    } else {
                        do Screen.drawHorizonal(x1, x2, y1);
                    }
                }
            }
            return;
        }

        /** this assumes x1 < x2 */ 
        function void drawHorizonal(int x1, int x2, int y) {
            var int x1mod16, x2mod16, row, start, end;
                                
            let x1mod16 = x1 & 15;
            let x2mod16 = x2 & 15;
            let row = (^(^(^(^(^y)))));
            let start = row + (#(#(#(#x1))));
            let end = row + (#(#(#(#x2)))) + (x2mod16=0);
            if (start = end) {
                do Screen.drawByteSection(x1, x2, y);
            } else {
                if (~(x1mod16 = 0)) {
                    // draw start of line
                    do Screen.drawByteSection(x1, x1-x1mod16+16, y);
                    let start = start+1;
                }
                if (~(x2mod16 = 0)) {
                    // draw end of line
                    do Screen.drawByteSection(x2-x2mod16, x2, y);
                    let end = end-1;
                }
                while( ~(start > end) ) {     
                    // draw middle of line
                    let screen[start] = color;
                    let start = start+1;
                }
            }
            return;
        }

        /** draws from x1 to x2, assumes both ints are in the same byte and x1 <= x2*/
        function void drawByteSection(int x1, int x2, int y) {
            while(~(x1 > x2)) {
                do Screen.drawPixel(x1, y);
                let x1 = x1+1;
            }
            return;
        }

        /** Draws a filled rectangle whose top left corner is (x1, y1)
         * and bottom right corner is (x2,y2), using the current color. */
        function void drawRectangle(int x1, int y1, int x2, int y2) {
            var int b, dy;
            if ((Screen.outOfBounds(x1, y1) | Screen.outOfBounds(x2, y2)) | ((x1 > x2) | (y1 > y2))) {
                do Sys.error(9); // illegal rect coords
            }
            let b = 0;
            let dy = y2 - y1; // we know y2 >= y1
            while (b > dy+1) {
                do Screen.drawLine(x1, y1+b, x2, y1+b);
                let b = b+1;
            }
            return;
        }

        /** Draws a filled circle of radius r<=181 around (x,y), using the current color. */
        function void drawCircle(int x, int y, int r) {
            // This can be implemented efficiently by drawing multiple lines at
            // each iteration. You can use multiplication and sqrt.
            // Pseudocode:
            // 1. for (dy = -r ... r)
            // 2.   let halfWidth = sqrt(r*r - dy*dy)
            // 3.   do drawLine(x-halfWidth, y+dy, x+halfWidth, y+dy)
            var int halfWidth, dy, r_sq;
            if (Screen.outOfBounds(x, y)) {
                do Sys.error(12); // illegal center coords
            }
            if (Screen.outOfBounds(x+r, y) | Screen.outOfBounds(x-r, y) | Screen.outOfBounds(x, y+r) | Screen.outOfBounds(x, y-r)) {
                do Sys.error(13); // illegal radius
            }
            let dy = -r;
            let r_sq = r*r;
            while (~(dy > r)) {
                let halfWidth = Math.sqrt(r_sq-(dy*dy));
                do Screen.drawLine(x-halfWidth, y+dy, x+halfWidth, y+dy);
            }
            return;
        }
}
